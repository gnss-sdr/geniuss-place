---
title: "Using Git"
permalink: /docs/tutorials/using-git/
excerpt: "Brief overview of Git usage in the context of GNSS-SDR."
author_profile: false
header:
  teaser: /assets/images/logo-git.png
tags:
  - tutorial
  - Git
sidebar:
  nav: "docs"
redirect_from:
  - /node/20
toc: true
toc_sticky: true
show_date: false
last_modified_at: 2021-01-27T12:54:02+02:00
---


One of the greatest advantages of open-source is the ability to view, modify and
share the source code. This means diagnosing and fixing problems, or adding new
features or documentation. In order to contribute these fixes/improvements to
the project's developers, you need to send them back your changes in an adequate
manner. This can be done by creating and sending a patch file, or by doing a
pull request. Scroll down for more details about how to do that.

For the version control system we use [Git](https://git-scm.com/), a free and
open-source application that automates the process of keeping an annotated
history of the project, allowing reversion of code changes, easy branching and
merging, sharing, and change tracking. The [GNSS-SDR's GitHub
repository](https://github.com/gnss-sdr/gnss-sdr) hosts all the data files
needed for version control, being the central "truth" repository resource of
GNSS-SDR's source code. Such a reference repository is usually referred to as
_upstream_.

A repository is simply a place where the history of the work is stored. The
distributed nature of Git allows users to
[clone](https://help.github.com/articles/cloning-a-repository/) this repository,
that is, to obtain an exact replica of the original repository at their own
local hard drive. Then, users can build and use the software, modify the source
code, share their work, and contribute back to GNSS-SDR. Git is a fantastic but
complex source code management system - it has a steep learning curve, but it
worth it. A good reference is the freely available [Git Pro
book](https://git-scm.com/book/en/v2), but there are plenty of good Git
tutorials out there. If you have never used it, start from the [Git
Basics](https://git-scm.com/book/en/v2/Getting-Started-Git-Basics) or this
[interactive  learning game that takes just 15
minutes](https://try.github.io/levels/1/challenges/1).

Branching in Git is one of its many great features. A
[branch](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell)
represents an independent line of development or, more accurately, a directed
acyclic graph of development. If you have used other version control systems, it
is probably helpful to forget most of what you think about branches - in fact,
it may be more helpful to think of them practically as contexts since that is
how you will most often be using them. When you checkout different branches, you
change the contexts that you are working in, and you can quickly context-switch
back and forth between several different branches. Every time you switch to a
new branch, you will actually see different files in your local folder.

In GNSS-SDR, the source code comes in two flavors: "`master`" and "`next`"
(these are in fact the names of the Git branches). While "`master`" is the main,
most stable branch that contains the latest release, "`next`" is where all the
development is happening, the most bleeding-edge code out there. Once you have
cloned the main repository, you can easily switch between these two branches (or
any other created by you or fetched from other users) by going to your
git-cloned repository and issuing the `git checkout` command with the name of
the desired branch name, like this:

```console
$ git checkout master   # now you are in the master branch
$ git checkout next     # now you are in the next branch
```
{: class="no-copy"}

If you do not know in which branch you are, pay attention to the first
line of this command's output:

```console
$ git status
```

## How to work with the source code and submit your changes

If you still not have one, please [sign up on GitHub](https://github.com/join)
and create your personal account (it's free).

The first thing you need to do in order to submit your changes to the GNSS-SDR
repository is to fork from it. This can be done either by following [this
link](https://github.com/gnss-sdr/gnss-sdr/fork), by clicking in the following
button:

[<i class="fab fa-github fa-lg"></i> Fork GNSS-SDR from GitHub](https://github.com/gnss-sdr/gnss-sdr/fork){: .btn .btn--geniuss .btn--x-large}
{: style="text-align: center;"}

or by browsing to
[https://github.com/gnss-sdr/gnss-sdr](https://github.com/gnss-sdr/gnss-sdr) and
clicking in the Fork button at the upper-right corner of the screen: ![Fork
button]({{ "/assets/images/fork_button.jpg" | relative_url }})

Once you have forked the repository, open a terminal, go to your favorite
working folder, and type:

```console
$ git clone https://github.com/YOUR_USERNAME/gnss-sdr
```
{: class="no-copy"}

where `YOUR_USERNAME` is your GitHub user name. Now, you have a local copy of
your fork of the GNSS-SDR repository into a directory called `gnss-sdr`. Change
to that directory:

```console
$ cd gnss-sdr
```

and (if you have not done so yet) [configure
Git](https://help.github.com/articles/set-up-git/) with some basic information,
such as your identity:

```console
$ git config user.name "Your Name"
$ git config user.email "your@email.abc"
```
{: class="no-copy"}

The email you specify should be the same one found in your [GitHub email
settings](https://help.github.com/articles/adding-an-email-address-to-your-github-account/).

When you fork a project in order to propose changes to the original repository,
you can configure Git to pull changes from the original, or _upstream_,
repository into the local clone of your fork. If you type `git remote -v` in a
terminal and press **Enter**, you will see the current configured remote
repository for your fork:

```console
$ git remote -v
origin  https://github.com/YOUR_USERNAME/gnss-sdr.git (fetch)
origin  https://github.com/YOUR_USERNAME/gnss-sdr.git (push)
```
{: class="no-copy"}

We can add the original, _upstream_ repository like this:

```console
$ git remote add upstream https://github.com/gnss-sdr/gnss-sdr.git
```

To verify the new upstream repository you have specified for your fork, type
`git remote -v` again. You should see the URL for your fork as `origin`, and the
URL for the original repository as `upstream`:

```console
$ git remote -v
origin    https://github.com/YOUR_USERNAME/gnss-sdr.git (fetch)
origin    https://github.com/YOUR_USERNAME/gnss-sdr.git (push)
upstream  https://github.com/gnss-sdr/gnss-sdr.git (fetch)
upstream  https://github.com/gnss-sdr/gnss-sdr.git (push)
```
{: class="no-copy"}

Now, you can keep your fork synced with the upstream repository with a few Git
commands:

  1.   Fetch the branches and their respective commits from the upstream
  repository. Commits to `next` will be stored in a local branch,
  `upstream/next`.

       ```console
$ git fetch upstream
       ```

  2.   Check out your fork's local `next` branch:

       ```console
$ git checkout next
       ```

  3.   Merge the changes from `upstream/next` into your local `next` branch.
  This brings your fork's `next` branch into sync with the upstream repository,
  without losing your local changes:

       ```console
$ git merge upstream/next
       ```


Now that you are up to date, go to the `next` branch and create a new branch off
from it:

```console
$ git checkout next
$ git checkout -b my_feature
```
{: class="no-copy"}

Whenever you want to work on something, create a branch for it. Then, do your
changes, stage modified and new files, and do commits:

```console
... (change files, compile, test) ...
$ git add file1.cc file1.h ...    # This is called file staging
$ git commit -m "adding stuff"    # Records staged files to the repository
```
{: class="no-copy"}

{% capture commit-text %}
<h4><a name="sign-your-commits"></a>Sign your commits!</h4>

If you plan to contribute your work back to the upstream repository in form of
pull request, it is required that you [sign your
commits](https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work) as an
indication of  [Developer's Certificate of
Origin](https://github.com/gnss-sdr/gnss-sdr/blob/next/.github/DCO.txt)
fulfillment. You have several ways to sign your commits:

  * **The `-s` flag:** `git commit -s -m "commit message"`. This adds a
  Signed-off-by trailer by the committer at the end of the commit log message.
  * **The `-S` flag:** `git commit -S -m "commit message"`. This will sign the
  commit with your GPG key (check [how to generate your GPG
  key](https://docs.github.com/en/github/authenticating-to-github/generating-a-new-gpg-key)
  and [how to tell Git about your signing
  key](https://docs.github.com/en/github/authenticating-to-github/telling-git-about-your-signing-key)).
  * **Preferred method:** To configure your Git client to sign commits by
  default for a local repository (so you don't need to add the `-S` flag to your
  commits anymore), in Git versions 2.0.0 and above, after generating your GPG
  key and telling Git about it, run:
  ```console
$ git config commit.gpgsign true
  ```
  To sign all commits by default in any local repository on your computer, run:
  ```console
$ git config --global commit.gpgsign true
  ```
{% endcapture %}
<div class="notice--info">
    {{ commit-text | markdownify }}
</div>

As you edit files, Git sees them as modified, because you have changed them
since your last commit. You stage these modified files and then commit all your
staged changes, and the cycle repeats. The command git add puts the files into a
"staging area", an index where you get to determine what changes get shipped
away in the next commit, that is, what files are going to be recorded to the
repository. If you need more details about this process, check this Git tutorial
on how to record changes in your repository. The next figure summarizes this
workflow:


![Git repository]({{ "/assets/images/git-repository.png" | relative_url }}){: .align-center .invert-colors}

Once you are done with your changes in your local repository, it's time to push
that changes to your GitHub repository:

```console
$ git push origin my_feature
```
{: class="no-copy"}

Then, go onto the GitHub site, visit your repository, switch to your
`my_feature` branch, and click the _Pull Request_ button that will do all the
work for you.

Once a pull request is sent, interested parties can review the set of changes,
discuss potential modifications, and even push follow-up commits if necessary.



## How to use someone else's branch {#app:someonelse}

As a collaboration tool, Git can set up what is known as a remote to connect to
other people's repositories. Those repositories, in the Git distributed system,
do not need to be on a single server but can be anywhere. You can have several
of them, each of which generally is either read-only or read/write for you.
Collaborating with others involves managing these remote repositories and
pushing and pulling data to and from them when you need to share work.

Now, someone might be doing something interesting you care about. Say this is
Carles Fernández and you want to track his work:

```console
$ git remote add cf git://github.com/carlesfernandez/gnss-sdr.git
$ git fetch cf    # This downloads all the content from Carles' repo.
$ git branch -r   # Lists remote branches
```
{: class="no-copy"}

Then you can see all your available remote branches (including those of the
remote repository you just added) and their name. You can then checkout a
specific remote branch by typing:

```console
$ git checkout cf/very_cool_feature
```
{: class="no-copy"}

When checking out a remote branch, you can look around, make experimental
changes and commit them, and you can discard any commits you make in this state
without impacting any branches by performing another checkout. If you want to
create a new branch to retain commits you are producing, you may do so (now or
later) by using `-b` with the `checkout` command again:

```console
$ git checkout -b new_branch_name
```
{: class="no-copy"}

## Setting up tracking branches

When you create a new local branch off from next, it diverges from your local
next at that point in time:

```console
$ git checkout next
$ git checkout --track -b my_feature
```
{: class="no-copy"}

If you want to keep that new branch updated with the new changes of next, you
either need to pull changes through next and then rebase your branch, or
remember where your merge point was.

What we have here is `my_feature` tracking `next`, and not `origin/next`; in
other words, it is a local branch tracking another local branch. There are times
when this is useful, but what if you want to track the remote one directly
instead of having to pull through a local copy? The solution is to have a
tracking branch.

In Git terminology, a tracking branch is a local branch that is connected to a
remote branch. When you `push` and `pull` on that branch, it automatically
pushes and pulls to the remote branch that it is connected with.

Checking out a local branch from a remote branch automatically creates a
tracking branch. If you are on a tracking branch and type `git push`, Git
automatically knows which server and branch to push to. Also, running `git pull`
while on one of these branches fetches all the remote references and then
automatically merges in the corresponding remote branch.

When you clone a repository, it automatically creates a master branch that
tracks origin/master. That is why `git push` and `git pull` work out of the box
with no other arguments: if you are on a tracking branch and type git push, Git
automatically knows which server and branch to push to. However, you can set up
other tracking branches if you wish - ones that do not track branches on
`origin` and do not track the `master` branch.

Say you want to work off the `next` branch. First, you need a copy of that in
your local repository - a tracking branch:

```console
$ git fetch --all    # This downloads all available content
$ git branch -r      # Lists remote branches
```
{: class="no-copy"}

Then, create a local tracking branch called `my_feature` from the remote branch
called `origin/next`:

```console
$ git checkout --track -b my_feature origin/next
```
{: class="no-copy"}

Now you have a branch `my_feature` which is tracking `origin/next`. When there
is an update in the upstream repository, and do a `pull`, you will see it
updating both `next`, and also `my_feature`.

**Important:** Never, ever commit (write) to a local tracking branch.
Always use them as a base to branch off!
{: .notice--danger}

## Good coding practices {#app:goodpractices}

-   **Keep your changes referred to the latest commit of `upstream/next`
    branch.** In Git terminology, this is called rebasing a branch. When
    rebasing, you need to specify which branch you want to rebase onto:

    ```console
$ git checkout my_feature
$ git fetch upstream
$ git rebase upstream/next
    ```
    {: class="no-copy"}
    This simply reshuffles your `my_feature` branch patches on top of the
    current `next branch` in the `upstream` remote. Rebasing is a good idea
    while your feature branch is still in development. Check out Scott Chacon's
    Git Pro book section about
    [rebasing](https://git-scm.com/book/en/v2/Git-Branching-Rebasing) to find
    out more details about this concept.

-   **Use an integrated development environment (IDE) with Git
    support.** Most modern C++ IDEs have nice interfaces for using Git.
    An open-source, well-known option is [Eclipse](https://www.eclipse.org/),
    and we love using [EGit](https://www.eclipse.org/egit/), an Eclipse Team
    provider for Git.

-   **Before creating the patch file, please be sure that after your
    modifications everything compiles and runs without problems, and clean up your
    work.** Remove any junk lines or comments you may have left while fixing the
    code, and make sure you follow the recommended [coding style]({{
    "/coding-style/" | relative_url }}) (indentation, white spaces, naming
    conventions, and so on). This will make other developers’ life easier.

-   **Tell us about your branch!** If you have significant changes, you
    can simply email us (again, the best way is by mailing list, so other
    users can get to know about your work) and tell us about your code.
    All we need is the link to your remote branch.


## Summary: GNSS-SDR's Git branching model

GNSS-SDR's reference Git repository, also referred to as _upstream_, is hosted
online by GitHub at
[https://github.com/gnss-sdr/gnss-sdr](https://github.com/gnss-sdr/gnss-sdr).
That repository holds two development branches with infinite lifetime, `master`
and `next`:

 * We consider
 [`upstream/master`](https://github.com/gnss-sdr/gnss-sdr/tree/master) to be the
 branch where the source code of HEAD (_i.e._, the result of the latest change)
 reflects the source code of the latest stable release, plus maybe some hot
 fixes (_e.g._, building issues).
 * We consider
 [`upstream/next`](https://github.com/gnss-sdr/gnss-sdr/tree/next) to be the
 main branch where the source code of HEAD always reflects a state with the
 latest delivered development changes ready for the next release. Some would
 call this the "integration branch", or the "current baseline" for new
 developments. If you are building the software from sources, or you want to
 start a new improvement, this is the branch to start with.

When the source code in the `next` branch reaches a stable point and is ready to
be released, all of the changes are merged back into `master` and then tagged
with a release number. List of GNSS-SDR releases
[here](https://github.com/gnss-sdr/gnss-sdr/releases).

Everyone is free to clone the upstream repository (_i.e._, to download an exact
copy of the whole source code repository content, including all development
branches and associated history) and to create an infinite number of new
"feature branches", such as `fixing-a-typo-in-the-docs` or
`adding-a-new-algorithm-for-Galileo-E1b-signal-acquisition`, in which specific
improvements can be implemented in a nonlinear and distributed manner. The
relation of Git to the PDCA (Plan-Do-Check-Act) cycles is described in the
[Testing the software receiver tutorial]({{
"/docs/tutorials/testing-software-receiver/" | relative_url }}).

Once a feature branch is ready for production, it can be merged back into
`upstream/next` and eventually included in the next `upstream/master` release.
The acceptance of new contributions to upstream is always supervised and
validated by the Developer Team, and every single change in the whole process
(including the authorship and a time tag) is registered in the repository for
future reference.

Next figure shows the Git branching model followed in GNSS-SDR's upstream
repository:


![GNSS-SDR's Git branching model]({{ "/assets/images/git-branching-model.png" | relative_url }}){: .align-center .invert-colors}
_A graphical representation of GNSS-SDR's Git branching model, where vertical
lines represent branches, colored dots represent commits, from older (top) to
newer (bottom), and arrows across branches represent merges. Feature branches
can be either in the upstream repository or in any other fork. This model is a
modified version from
[V. Driessen](https://nvie.com/posts/a-successful-git-branching-model/)_.
{: style="text-align: center;"}
